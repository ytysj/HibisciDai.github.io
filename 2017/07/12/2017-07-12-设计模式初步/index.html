<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="设计模式初步"><meta name="keywords" content="设计模式"><meta name="author" content="HibisciDai,undefined"><meta name="copyright" content="HibisciDai"><title>设计模式初步 | HibisciDai</title><link rel="shortcut icon" href="/img/Avatar.png"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.1"><script>var GLOBAL = { 
  root: '/',
  algolia: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  localSearch: undefined
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/Avatar.png"></div><div class="author-info__name text-center">HibisciDai</div><div class="author-info__description text-center">HibisciDai'Blog</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">32</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">27</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">11</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" href="https://github.com/HibisciDai/hexo-theme-melody" target="_blank">HexoTheme-github</a><a class="author-info-links__name text-center" href="https://molunerfinn.com/" target="_blank">molunerfinn</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/banner2.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">HibisciDai</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">主页</a><a class="site-page" href="/about">关于我</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span></div><div id="post-info"><div id="post-title">设计模式初步</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-07-12</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/设计模式/">设计模式</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div id="post-content"><p><a href="http://www.runoob.com/design-pattern/design-pattern-tutorial.html" target="_blank" rel="noopener">设计模式 | 菜鸟教程</a><br>参考书：<strong>Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）</strong><br>23种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。</p>
<p><style>table th:first-of-type(2) {width: 60px;}</style><br>|序号 | 模式&amp;描述 | 包括 |<br>|:– | :-| :———- |<br>| 1  | <strong>创建型模式</strong><br>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用新的运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 | -工厂模式（Factory Pattern）<br>-抽象工厂模式（Abstract Factory Pattern）<br>-单例模式（Singleton Pattern）<br>-建造者模式（Builder Pattern）<br>-原型模式（Prototype Pattern）|<br>| 2  | <strong>结构型模式</strong><br>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 |  -适配器模式（Adapter Pattern）<br>-桥接模式（Bridge Pattern）<br>-过滤器模式（Filter、Criteria Pattern）<br>-组合模式（Composite Pattern）<br>-装饰器模式（Decorator Pattern）<br>-外观模式（Facade Pattern）<br>-享元模式（Flyweight Pattern）<br>-代理模式（Proxy Pattern）  |<br>| 3  | <strong>行为型模式</strong><br>这些设计模式特别关注对象之间的通信。| -责任链模式（Chain of Responsibility Pattern）<br>-命令模式（Command Pattern）<br>-解释器模式（Interpreter Pattern）<br>-迭代器模式（Iterator Pattern）<br>-中介者模式（Mediator Pattern）<br>-备忘录模式（Memento Pattern）<br>-观察者模式（Observer Pattern）<br>-状态模式（State Pattern）<br>-空对象模式（Null Object Pattern）<br>-策略模式（Strategy Pattern）<br>-模板模式（Template Pattern）<br>-访问者模式（Visitor Pattern） |<br>| 4  |<strong>J2EE 模式</strong><br>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。| -MVC 模式（MVC Pattern）<br>-业务代表模式（Business Delegate Pattern）<br>-组合实体模式（Composite Entity Pattern）<br>-数据访问对象模式（Data Access Object Pattern）<br>-前端控制器模式（Front Controller Pattern）<br>-拦截过滤器模式（Intercepting Filter Pattern）<br>-服务定位器模式（Service Locator Pattern）<br>-传输对象模式（Transfer Object Pattern）|</p>
<p>设计模式之间的关系<br><img src="http://img.blog.csdn.net/20170712104740188?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGo3NDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="设计模式之间的关系"></p>
<p>#设计模式的六大原则</p>
<p>##1、开闭原则（Open Close Principle）<br>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<p>##2、里氏代换原则（Liskov Substitution Principle）<br>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<p>##3、依赖倒转原则（Dependence Inversion Principle）<br>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
<p>##4、接口隔离原则（Interface Segregation Principle）<br>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p>
<p>##5、迪米特法则，又称最少知道原则（Demeter Principle）<br>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<p>##6、合成复用原则（Composite Reuse Principle）<br>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p>
<p>#单例模式<br>提供创建对象的最佳方式。涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。该类提供一种访问其唯一的对象的方式，可以直接访问，不需要创建对象。<br>注意：1.单例类只能有一个实例。2.单例类必须自己创建自己的唯一实例。3.单例类必须给所有其他对象提供这一实例。</p>
<p><em>eg<br>在模拟学校运营模式的程序中，校长一实例为唯一实例，全局使用的类而且会参与全校事务处理，即频繁使用与销毁该类对象。由于此对象太特殊又为唯一值且频繁参与程序运行过程。所以为该校长类创建实例。</em></p>
<p>#工厂模式</p>
<p>##简单工厂模式<br>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。创建对象过程在非工厂类中执行，耦合分离的思想。</p>
<p><em>eg<br>汽车制造厂，再制造汽车前所有汽车都有一个统一标准，然后根据型号对不同汽车进行设计组装，最后汽车分为很多种，制造过程由工厂承办，不同型号的车由不同厂商指定，工厂只是接到参数进行组装。</em></p>
<p>##静态工厂模式<br>一个类代表另一个类的功能，属于结构型模式。创建具有现有对象的对象，以便向外界提供功能接口。<br>为其他对象提供一种代理以控制这个对象的访问。代理对象可以在客户和目标对象之间起到中介作用。<br>每个代理只能为一个接口服务，代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任了。另外如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。</p>
<p><em>eg<br>火车站销售问题，卖票是一种功能方法（抽象主题角色），该方法由火车站（真实主题角色）实现，但对于这一流程的实现，不能买一张票新建创建一个火车站（现实中是不可能实现的），创建代售点（代理主题角色）也可以实现售票功能。</em></p>
<p>##抽象工厂模式<br>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
<p><em>eg<br>换皮肤，更改产品的一套属性。</em></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">HibisciDai</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://hibiscidai.com/2017/07/12/2017-07-12-设计模式初步/">http://hibiscidai.com/2017/07/12/2017-07-12-设计模式初步/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://hibiscidai.com" target="_blank">HibisciDai</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/设计模式/">设计模式</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/zhifubaodashang.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/weixin.png"><div class="post-qr-code__desc">微信打赏</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2017/07/15/2017-07-15-Java内存机制详解JVM初步/"><i class="fa fa-chevron-left">  </i><span>Java内存机制详解|JVM初步</span></a></div><div class="next-post pull-right"><a href="/2017/07/12/2017-07-12-JAVA反射机制/"><span>JAVA反射机制</span><i class="fa fa-chevron-right"></i></a></div></nav><div class="post-adv"></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2018 By HibisciDai</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.1"></script><script src="/js/fancybox.js?version=1.5.1"></script><script src="/js/sidebar.js?version=1.5.1"></script><script src="/js/copy.js?version=1.5.1"></script><script src="/js/fireworks.js?version=1.5.1"></script><script src="/js/transition.js?version=1.5.1"></script><script src="/js/scroll.js?version=1.5.1"></script><script src="/js/head.js?version=1.5.1"></script></body></html>